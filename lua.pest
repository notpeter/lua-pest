CHUNK = { BLOCK }
BLOCK = { STAT* ~ RETURN_STATUS? }
STAT = {
    ";"
    | (VAR_LIST ~ "=" ~ EXP_LIST)
    | FUNCTION_CALL
    | LABEL
    | "break"
    | ("goto" ~ NAME)
    | ("do" ~ BLOCK ~ "end")
    | ("while" ~ EXP ~ "do" ~ BLOCK ~ "end")
    | ("repeat" ~ BLOCK ~ "until" ~ EXP)
    | ("if" ~ EXP ~ "then" ~ BLOCK ~ ("elseif" ~ EXP ~ "then" ~ BLOCK)* ~ ("else" ~ BLOCK)? ~ "end")
    | ("for" ~ NAME ~ "=" ~ EXP ~ "," ~ EXP ~ ("," ~ EXP)? ~ "do" ~ BLOCK ~ "end")
    | ("for" ~ NAME_LIST ~ "in" ~ EXP_LIST ~ "do" ~ BLOCK ~ "end")
    | ("function" ~ FUNCTION_NAME ~ FUNCTION_BODY)
    | ("local" ~ FUNCTION_NAME ~ FUNCTION_BODY)
    | ("local" ~ ATTRIBUTE_NAME_LIST ~ ("=" ~ EXP_LIST)?)
}

ATTRIBUTE_NAME_LIST = { NAME ~ ATTRIB ~ ("," ~ NAME ~ ATTRIB)* }
RETURN_STATUS = { "return" ~ EXP_LIST? ~ ";"? }
ATTRIB = { "<" ~ NAME ~ ">" }
LABEL = { "::" ~ NAME ~ "::" }
FUNCTION_NAME = { NAME ~ ( "." ~ NAME )* ~ ( ":" ~ NAME )? }
VAR_LIST = { VAR ~ ("," ~ VAR)* }
EXP_LIST = { EXP ~ ("," ~ EXP)* }

EXP = {
    "nil" | "false" | "true" | NUMERAL | LITERAL_STRING
    | "..." // note: valid in vararg parameter lists or vararg function body
    | FUNCTION_DEF
    // | PREFIX_EXP
    | TABLE_CONSTRUCTOR
    // | (EXP ~ BINOP ~ EXP)
    | (UNOP ~ EXP)
}
PREFIX_EXP = {
    VAR
    // | FUNCTION_CALL
    // | ( "(" ~ EXP ~ ")" )
}
VAR = {
    NAME
    // | (PREFIX_EXP ~ "[" ~ EXP ~ "]")
    // | (PREFIX_EXP ~ "." ~ NAME)
}
FUNCTION_CALL = {
    (PREFIX_EXP ~ ARGS)
    | (PREFIX_EXP ~ ":" ~ NAME ~ ARGS)
}

ARGS  = {
    ( "(" ~ EXP_LIST? ~ ")" )
    | TABLE_CONSTRUCTOR
    | LITERAL_STRING
}
FUNCTION_DEF = { "function" ~ FUNCTION_BODY }
FUNCTION_BODY = { "(" ~ PARAM_LIST? ~ ")" ~ BLOCK ~ "end" }

PARAM_LIST = { "..." | (NAME_LIST ~ ("," ~ "...")?) }
NAME_LIST = { NAME ~ ("," ~ NAME)* }

TABLE_CONSTRUCTOR = { "{" ~ FIELD_LIST ~ "}" }
FIELD_LIST = { FIELD ~ (FIELD_SEP ~ FIELD)* ~ FIELD_SEP? }
FIELD_SEP = { "," | ";" }
FIELD = { ("[" ~ EXP ~ "]" ~ "=" ~ EXP) | (NAME ~ "=" ~ EXP) | EXP }

BINOP = {
    "+" | "-" | "*" | "/" | "//" | "^" | "%"
    | "&" | "~" | "|" | ">>" | "<<" | ".."
    | "<" | "<=" | ">" | ">=" | "==" | "~="
    | "and" | "or"
}
UNOP = { "-" | "not" | "#" | "~" }

NAME = { (ASCII_ALPHA | "_") ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* }

VALUE = { NUMERAL | LITERAL_STRING }

// TODO: support long brackets [[ ... ]] [==[ ... ]==] and the like
// https://www.lua.org/manual/5.4/manual.html#3.1
LITERAL_STRING = _{ QUOTE ~ STRING ~ QUOTE}
STRING = @{ (ESCAPE | ASCII_ALPHANUMERIC)* }
ESCAPE = _{ ESCAPE_C | ESCAPE_X | ESCAPE_D }
ESCAPE_C = _{
    "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v" | "\\\\" | "\\'" | "\\\""
    | ("\\z" ~ (NEWLINE | " ")*)
}
ESCAPE_X = _{ "\\x" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT }
ESCAPE_D = _{
    "\\" ~ (
        (("0" | "1") ~ ASCII_DIGIT ~ ASCII_DIGIT)
        | ("2" ~ ("0" | "1" | "2" | "3" | "4") ~ ASCII_DIGIT)
        | ("25" ~ ("0" | "1" | "2" | "3" | "4" | "5"))
        | (ASCII_DIGIT ~ ASCII_DIGIT? ~ !ASCII_DIGIT)
    )
}
QUOTE = _{ "\"" }

NUMERAL = { HEX_FLOAT | HEX_INTEGER | FLOAT | INTEGER }

HEX_FLOAT = @{
    ("0x" | "0X")
    ~ ASCII_HEX_DIGIT+
    ~ ("." ~ ASCII_HEX_DIGIT*)?
    ~ FLOAT_HEX_EXPONENT?
    ~ FRACTIONAL_PART?
}
FLOAT = @{
	( ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT* ~ FLOAT_LITERAL_EXPONENT? )
	| ( "." ~ ASCII_DIGIT+ ~ FLOAT_LITERAL_EXPONENT? )
    | (ASCII_DIGIT+ ~ FLOAT_LITERAL_EXPONENT)
}
FLOAT_LITERAL_EXPONENT = { ("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+ }
FLOAT_HEX_EXPONENT = { ("e" | "E") ~ (("+" | "-")? ~ ASCII_DIGIT+)? }
FRACTIONAL_PART = { ("p" | "P") ~ ("+" | "-")? ~ ASCII_DIGIT+ }
HEX_INTEGER = { ("0x" | "0X") ~ ASCII_HEX_DIGIT+ }
INTEGER = { ASCII_DIGIT+ }

// This pest.rs magic. https://pest.rs/book/grammars/syntax.html#implicit-whitespace
WHITESPACE = _{ " " | NEWLINE }
// COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

/* These are pest.rs built-in rules. Included here for sanity.
ASCII_DIGIT	        = { '0'..'9' }
ASCII_NONZERO_DIGIT	= { '1'..'9' }
ASCII_BIN_DIGIT	    = { '0'..'1' }
ASCII_OCT_DIGIT	    = { '0'..'7' }
ASCII_HEX_DIGIT	    = { '0'..'9' | 'a'..'f' | 'A'..'F' }
ASCII_ALPHA_LOWER	= { 'a'..'z' }
ASCII_ALPHA_UPPER	= { 'A'..'Z' }
ASCII_ALPHA         = { 'a'..'z' | 'A'..'Z' }
ASCII_ALPHANUMERIC	= { ASCII_DIGIT | ASCII_ALPHA }
NEWLINE             = { "\n" | "\r\n" | "\r" }
*/
